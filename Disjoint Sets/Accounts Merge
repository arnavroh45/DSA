Approach: add the same email's username to the disjoint set and put the other username as the parent and then just find all the emails under that username
Code:
class DisjointSet
    {
        public:
        vector<int> parent, rank, size;
        int n;
        DisjointSet(int n)
        {
            rank.resize(n+1, 0);
            size.resize(n+1, 1);
            parent.resize(n+1);
            for(int i = 0;i<=n;i++)
                parent[i] = i;
        }
        int find(int x)
        {
            if(x==parent[x])
                return x;
            return parent[x] = find(parent[x]);
        }
        void union_by_rank(int x, int y)
        {
            int par_x = find(x);
            int par_y = find(y);
            if(par_x==par_y)
                return;
            else
            {
                if(rank[par_x]>rank[par_y])
                    parent[par_y] = par_x;
                else if(rank[par_x]<rank[par_y])
                    parent[par_x] = par_y;
                else
                {
                    parent[par_y] = par_x;
                    rank[par_x]++;
                }
            }
        }
        void union_by_size(int x, int y)
        {
            int par_x = find(x);
            int par_y = find(y);
            if(par_x==par_y)
                return;
            else
            {
                if(size[par_x]>size[par_y])
                {
                    parent[par_y] = par_x;
                    size[par_x] += size[par_y];
                }
                else
                {
                    parent[par_y] = par_x;
                    size[par_x] += size[par_y];
                }
            }
        }
    };
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        DisjointSet ds(accounts.size());
        unordered_map<string, int> umap;
        for(int i = 0;i<accounts.size();i++)
        {
            for(int j = 1;j<accounts[i].size();j++)
            {
                if(umap.find(accounts[i][j])==umap.end())
                    umap[accounts[i][j]] = i; 
                else
                    ds.union_by_size(i, umap[accounts[i][j]]);
            }
        }
        unordered_map<int, vector<string>> total_components;
        for(auto i : umap)
        {
            string email = i.first;
            int group = i.second;
            total_components[ds.find(group)].push_back(email);
        }
        vector<vector<string>> final_accounts;
        for(auto i : total_components)
        {
            int group = i.first;
            vector<string> component = {accounts[group][0]};
            component.insert(component.end(), i.second.begin(), i.second.end());
            sort(component.begin()+1, component.end());
            final_accounts.push_back(component);
        }
        return final_accounts;
    }
