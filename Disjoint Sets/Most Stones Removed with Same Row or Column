Approach: Just connect the rows and columns that contain the stones in a disjoint set and check at last the number of components, we just maxxrow and maxxcol because humein columns ko bhi accomodate karna that
disjoint set mai, and ab 0th row and 0th column mai ambiguity hoti, isliye humne maxxrow add kara usmai

class DisjointSet
    {
        public:
        vector<int> parent, rank, size;
        int n;
        DisjointSet(int n)
        {
            rank.resize(n+1, 0);
            size.resize(n+1, 1);
            parent.resize(n+1);
            for(int i = 0;i<=n;i++)
                parent[i] = i;
        }
        int find(int x)
        {
            if(x==parent[x])
                return x;
            return parent[x] = find(parent[x]);
        }
        void union_by_rank(int x, int y)
        {
            int par_x = find(x);
            int par_y = find(y);
            if(par_x==par_y)
                return;
            else
            {
                if(rank[par_x]>rank[par_y])
                    parent[par_y] = par_x;
                else if(rank[par_x]<rank[par_y])
                    parent[par_x] = par_y;
                else
                {
                    parent[par_y] = par_x;
                    rank[par_x]++;
                }
            }
        }
        void union_by_size(int x, int y)
        {
            int par_x = find(x);
            int par_y = find(y);
            if(par_x==par_y)
                return;
            else
            {
                if(size[par_x]>size[par_y])
                {
                    parent[par_y] = par_x;
                    size[par_x] += size[par_y];
                }
                else
                {
                    parent[par_y] = par_x;
                    size[par_x] += size[par_y];
                }
            }
        }
    };
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        DisjointSet ds(accounts.size());
        unordered_map<string, int> umap;
        for(int i = 0;i<accounts.size();i++)
        {
            for(int j = 1;j<accounts[i].size();j++)
            {
                if(umap.find(accounts[i][j])==umap.end())
                    umap[accounts[i][j]] = i; 
                else
                    ds.union_by_size(i, umap[accounts[i][j]]);
            }
        }
        unordered_map<int, vector<string>> total_components;
        for(auto i : umap)
        {
            string email = i.first;
            int group = i.second;
            total_components[ds.find(group)].push_back(email);
        }
        vector<vector<string>> final_accounts;
        for(auto i : total_components)
        {
            int group = i.first;
            vector<string> component = {accounts[group][0]};
            component.insert(component.end(), i.second.begin(), i.second.end());
            sort(component.begin()+1, component.end());
            final_accounts.push_back(component);
        }
        return final_accounts;
    }
    int removeStones(vector<vector<int>>& stones) {
        int maxxrow = 0;
        int maxxcol = 0;
        for(auto i : stones)
        {
            maxxrow = max(maxxrow, i[0]);
            maxxcol = max(maxxcol, i[1]);
        }
        DisjointSet ds(maxxrow+maxxcol+1);
        unordered_map<int, int> stone_nodes;
        for(auto i : stones)
        {
            ds.union_by_size(i[0], i[1]+maxxrow+1);
            stone_nodes[i[0]] = 1;
            stone_nodes[i[1]+maxxrow+1] = 1;
        }
        int count_components = 0;
        for(auto i : stone_nodes)
        {
            if(ds.find(i.first)==i.first)
                count_components++;
        }
        return stones.size()-count_components;
    }
