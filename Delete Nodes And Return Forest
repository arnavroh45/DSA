Approach: uset is used for easily finding whether a value is present in the to_delete array or not, anss is used to store the final answer, del is used to store the nodes that are to be deleted, q is used
BFS traversal
1. we first find the nodes that are to be deleted, as we were given only the values of the nodes, using BFS. 
2. If the current node ka left/right needs to be deleted we add the left/array in the del array
and make the value in the current graph as NULL, we also add it to the queue to check whether other nodes are to be deleted in that path.
3. After performing BFS, we iterate over the del array, and and check if the left/right of that is present in the list or not, if it is not present then we add it in the final answer
4. finally we return the solution

Code:
vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        unordered_set<int> uset(to_delete.begin(), to_delete.end());
        vector<TreeNode*> anss, del;
        queue<TreeNode*> q;

        q.push(root);
        if(uset.count(root->val)==0)
            anss.push_back(root);
        else
            del.push_back(root);
        while(!q.empty())
        {
            auto node = q.front();
            q.pop();
            if(node->left)
            {
                if(uset.count(node->left->val)>0)
                {
                    del.push_back(node->left);
                    q.push(node->left);
                    node->left = NULL;
                }
                else
                    q.push(node->left);
            }
            if(node->right)
            {
                if(uset.count(node->right->val)>0)
                {
                    del.push_back(node->right);
                    q.push(node->right);
                    node->right = NULL;
                }
                else
                    q.push(node->right);
            }   
        }
        for(auto i : del)
        {
            uset.erase(i->val);
            if(i->left)
            {
                if(uset.count(i->left->val)>0)
                    continue;
                else
                    anss.push_back(i->left);
            }
            if(i->right)
            {
                if(uset.count(i->right->val)>0)
                    continue;
                else
                    anss.push_back(i->right);
            }   
        }
        return anss;
    }
